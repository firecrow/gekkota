src/core/debug.c:    print_value(head->source);
src/core/debug.c:    if(head->operator){
src/core/debug.c:        printf(" opp type %d", head->operator->type);
src/core/debug.c:    print_value(head->value);
src/core/debug.c:        print_tree(ctx->head->closure->symbols);
src/core/head.c:        head->operator = value->slot.operator->new(value->slot.operator->type);
src/core/head.c:        head->cell = cell;
src/core/head.c:        head->operator = new_function_operator(FUNCTION);
src/core/head.c:        head->cell = value->slot.cell;
src/core/head.c:        head->operator = new_default_operator(DEFAULT);
src/core/head.c:        head->value = value;
src/core/head.c:        head->cell = cell;
src/core/head.c:    head->closure = new_closure(closure);
src/core/head.c:    head->source = value;
src/core/head.c:    print_cell(head->cell->next);
src/operators/arithmetic_op.c:    if(!head->value){
src/operators/arithmetic_op.c:        head->value = clone_value(value);
src/operators/arithmetic_op.c:        head->value->slot.integer += new_value; 
src/operators/arithmetic_op.c:        head->value->slot.integer -= new_value;
src/operators/arithmetic_op.c:        head->value->slot.integer = head->value->slot.integer / new_value;
src/operators/arithmetic_op.c:        head->value->slot.integer = head->value->slot.integer * new_value;
src/operators/condition_op.c:        op->next = ctx->head->cell->next;
src/operators/condition_op.c:            ctx->head->value = ctx->cell->value;
src/operators/context_op.c:        ctx->head->value = ctx->previous->value;
src/operators/default_op.c:        ctx->head->value = ctx->previous->value;
src/operators/equal_op.c:        head->value =  ctx->builtins.true;
src/operators/equal_op.c:        head->value = ctx->builtins.true;
src/operators/equal_op.c:        head->value = ctx->builtins.false;
src/operators/function_op.c:        tree_add(ctx->head->closure->symbols, str("value"), ctx->cell->value);
src/operators/function_op.c:    struct cell *func = ctx->head->cell->value->slot.cell;
src/operators/function_op.c:    ctx->head = setup_new_head(new_head(), func, ctx->head->closure);
src/operators/io_op.c:    if(tree_get(ctx->head->closure->symbols, str("head")) != NULL){
src/operators/io_op.c:    }else if(tree_get(ctx->head->closure->symbols, str("cell")) != NULL){
src/operators/io_op.c:    }else if(tree_get(ctx->head->closure->symbols, str("tree")) != NULL){
src/operators/io_op.c:        print_tree(ctx->head->closure->symbols);
src/operators/io_op.c:    }else if(tree_get(ctx->head->closure->symbols, str("data")) != NULL){
src/operators/io_op.c:        struct closure *closure = ctx->head->closure;
src/operators/io_op.c:        ctx->head->value = ctx->value;
src/operators/set_op.c:    struct order_entry *oentry = ctx->head->closure->symbols->order;
src/operators/set_op.c:            struct closure *closure = ctx->head->closure->parent;
src/operators/string_op.c:    if(ctx->head->value.string == NULL){
src/operators/string_op.c:        ctx->head->value.string = clone_string(ctx->cell->value->slot.string);     
src/operators/string_op.c:        string_append(ctx->head->value.string, ctx->cell->value->slot.string); 
src/run/process_keys.c:        tree_update(ctx->head->closure->symbols, value->slot.string, ctx->builtins.nil);
src/run/process_keys.c:        ctx->head->key_for_next = value;
src/run/process_keys.c:    }else if(value && ctx->head->key_for_next){
src/run/process_keys.c:        tree_update(ctx->head->closure->symbols, ctx->head->key_for_next->slot.string, value);
src/run/process_keys.c:        ctx->head->key_for_next = NULL;
src/run/state.c:    ctx->head = setup_new_head(new_head(), ctx->cell, ctx->head->closure);
src/run/state.c:    ctx->head->closure = ctx->head->closure;
src/run/state.c:    head->value = previous->value;
src/run/state.c:    ctx->value = head->value;
src/run/state.c:    head->operator->handle(head->operator, ctx);
src/run/state.c:    ctx->head->operator->handle(ctx->head->operator, ctx);
src/run/state.c:    ctx->value = swap_for_symbol(ctx->head->closure, ctx->cell->value);
src/run/state.c:    /*while(ctx->cell->branch || ctx->head->cell->branch){*/
src/run/state.c:        start_new_branch(ctx, ctx->cell->branch, ctx->head->closure);
src/run/state.c:    ctx->value = swap_for_symbol(ctx->head->closure, ctx->cell->value);
src/run/state.c:        ctx->head->operator->handle(ctx->head->operator, ctx);
test/unit.c:    test(suite, head->operator->type == DEFAULT, "No operator if cell has no value");
test/unit.c:    test(suite, head->operator->type == DEFAULT, "Operator should not be set if value is not function");
test/unit.c:    test(suite, head->operator != NULL, "Operator should be set from closure");
test/unit.c:    test(suite, state->head->closure->parent == global, "Global are assinged");
test/unit.c:    test(suite, state->head->value->slot.integer == 2, "Arithemtic comes up with proper value");
test/unit.c:    test(suite, tree_get(state->head->closure->symbols, str("one"))->slot.integer = 1,"Variable one is set with value 1");
test/unit.c:    test(suite, state->head->value->slot.integer == 3, "Final value reflects variable value");
test/unit.c:    test(suite, state->head->value->type == SL_TYPE_STRING, "head value is string");
test/unit.c:    test(suite, string_cmp(state->head->value->slot.string, str("hi")) == 0, "string is the content of the string");
test/unit.c:    test(suite, state->head->value->type == SL_TYPE_INT, "head value is int");
test/unit.c:    test(suite, state->head->value->slot.integer == 9, "arithmetic valu is the cntent of the cells");
