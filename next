src/core/cell.c:    if(cell->value == NULL){
src/core/cell.c:        cell->value = new_value();
src/core/cell.c:    return cell->value;
src/core/cell.c:   cell->id = next_cell_id++;
src/core/cell.c:    return cell->branch != NULL;
src/core/debug.c:    printf("<C%d ", cell->id);
src/core/debug.c:    if(cell->value){
src/core/debug.c:        print_value(cell->value);
src/core/debug.c:    printf("C(n%d/h%d", cell->next != NULL, cell->branch != NULL);
src/core/head.c:    struct value_obj *value = swap_for_symbol(closure, cell->value);
src/core/parse.c:    cell->value = value_from_token(state, token);
src/core/parse.c:        stack_cell->branch = new;
src/operators/condition_op.c: * and have cell->next be the result of each branch
src/operators/condition_op.c:        op->next = ctx->head->cell->next;
src/operators/default_op.c:        print_cell(ctx->cell->next);
src/operators/default_op.c:        ctx->cell = ctx->cell->next;
src/operators/string_op.c:    if(!ctx->cell->value || ctx->cell->value->type != STRING){
src/operators/string_op.c:        ctx->head->value.string = clone_string(ctx->cell->value->slot.string);     
src/operators/string_op.c:        string_append(ctx->head->value.string, ctx->cell->value->slot.string); 
src/run/process_keys.c:    struct value_obj *value = ctx->cell->value;
src/run/process_keys.c:        if(ctx->cell->branch){
src/run/process_keys.c:            value = new_cell_value_obj(ctx->cell->branch); 
src/run/state.c:        ctx->cell = ctx->stack->cell->next;
src/run/state.c:        if(ctx->cell->branch){
src/run/state.c:            ctx->head = setup_new_head(new_head(), ctx->cell->branch, ctx->head->closure);
src/run/state.c:            ctx->cell = ctx->cell->branch;
src/run/state.c:        ctx->value = swap_for_symbol(ctx->head->closure, ctx->cell->value);
test/unit.c:    cell->value = value;
test/unit.c:    cell->value = new_value();
test/unit.c:    cell->value->type = SL_TYPE_SYMBOL;
test/unit.c:    cell->value->slot.string = op_name;
