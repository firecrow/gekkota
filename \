#include "../gekkota.h"

void parse_char(struct parse_ctx *ctx, char c);

static enum match_state {
  GKA_PARSE_NOT_STARTED = 0,
  GKA_PARSE_PARTIAL,
  GKA_PARSE_IN_MATCH,
  GKA_PARSE_DONE
};

static typedef struct match_state (*pattern_incr_func)(struct cell_match_pattern *pattern, char c);

struct match_pattern {
  enum match_type type;  
  enum match_state state;
  bool in_escape;
  struct string token;
  pattern_incr_func incr; 
  void *data;
};


#define GKA_PATTERN_COUNT 9
#define GKA_PATTERN_START 0 
struct pattern_incr_func patterns[GKA_PATTERN_COUNT] = {
  string_incr
  open_cell
  close_cell
  quote_incr
  key_incr
  not_incr
  incr_incr
  number_incr
  symbol_incr
};

struct parse_ctx *new_parse_ctx(){
    struct parse_ctx *ctx = malloc(sizeof(struct parse_ctx));

    if(ctx == NULL){
        return NULL;
    }
    memset(ctx, 0, sizeof(struct parse_ctx));
    return ctx;
}

void setup_parse_ctx(struct parse_ctx *ctx){
  for(int i = 0; i< GKA_PATTERN_COUNT; i++){
    struct match_pattern *pattern = malloc(sizeof(struct match_pattern));
    memset(pattern, 0, sizeof(struct match_pattern));
    pattern->incr = patterns[i];
    ctx->patterns[i] = pattern; 
  }
}

static struct stack_item *push_parse_stack(struct stack_item *existing, struct cell *cell, struct head *head){
    struct stack_item *item = new_stack_item(existing, cell, head);
    return item;
}

struct cell *parse_all(struct string *string){
    struct parse_ctx *ctx = new_parse_ctx();

    if(ctx == NULL){
        char msg[] = "Error allocating parse context, aborting";
        write(STDERR, msg, strlen(msg));
        exit(1);
    }

    int l = string->length;
    for(int i = 0; i<l; i++){
       parse_char(ctx, string->content[i]);
    }

    return ctx->root; 
}

struct cell*parse_file(int fd){
    char buffer[1];

    struct parse_ctx *ctx = new_parse_ctx();
    if(ctx == NULL){
        char msg[] = "Error allocating parse context, aborting";
        write(STDERR, msg, strlen(msg));
        exit(1);
    }
    
    while(read(fd, buffer, 1) > 0){
       parse_char(ctx, buffer[0]);
    }
    return ctx->root; 
}

void assign_cell_attributes(enum SL_PARSE_STATE state, struct cell *cell, struct string *token){
    cell->value = value_from_token(state, token);
}

bool is_whitespace(char c){
    return c == ' ' || c == '\t' || c == '\n';
}

void finalize_cell(struct parse_ctx *ctx){
    if(ctx->token){
        assign_cell_attributes(ctx->state, ctx->current, ctx->token);
        ctx->token = NULL;
    }
    if(ctx->state != START){
        ctx->prev_state = ctx->state;
    }
    if(ctx->state != IN_QUOTE){
        ctx->state = START;
    }
}

struct string *get_or_create_token(struct parse_ctx *ctx){
    if(!ctx->token)
        ctx->token = new_string();
    return ctx->token;
}

void parse_char(struct parse_ctx *ctx, char c){
  int pattern_idx = GKA_PATTERN_START;
  struct match_pattern *current = NULL;
  enum match_state result = GKA_PARSE_NOT_STARTED;

  while(pattern_idx < GKA_PATTERN_COUNT){
    current = ctx->patterns[patter_idx++];
    current->incr(current, ctx);
    if(pattern->state > GKA_PARTIAL){
      break;
    }
  }
}

/* ----- string ----- */
void string_incr(struct cell_match_pattern *pattern, char c){
    if(pattern->state == GKA_NOT_STARTED){
      if(c == '"'){
        pattern->state = GKA_PARSE_IN_MATCH;
        return;
      }
    }
    if(pattern->state == IN_MATCH){
        if(c == '\\'){
            /* if we are escaping the \ then take no action */
            if(pattern->in_escape){
                pattern->in_escape = 0;
            }else{
                pattern->in_escape = 1;
                return;
            }
        }
        if(pattern->in_escape){
            pattern->in_escape = 0;
            if(c == 'n'){
                c = '\n';
            }
            if(c == 't'){
                c = '\t';
            }
        }

        if(!pattern->in_escape && c == '"'){
            pattern->state = GKA_PARSE_DONE;
            ctx->slot = ctx->current;
            ctx->current = new_string_value_obj(pattern->token);
            ctx->slot->next = ctx->current;
        }else{
            string_append_char(pattern->token, c);
        }
    }
}
/* ----- open cell ----- */
void open_incr(struct cell_match_pattern *pattern, char c){
  if(c == '('){
    new = new_cell();
    if(ctx->accent == GKA_PARSE_IN_QUOTE){
        ctx->current->value = new_cell_value_obj(new);
        ctx->stack = push_parse_stack(ctx->stack, ctx->current, NULL);
        ctx->current = new;
    }else{
        stack_cell = new_cell();
        stack_cell->branch = new;

        slot = ctx->current;

        ctx->current = new;
        ctx->stack = push_parse_stack(ctx->stack, stack_cell, NULL);

        if(!ctx->root){
            ctx->root = stack_cell;
        }else{
            if(slot){
                slot->next = stack_cell;
            }
        }
    }
    pattern->state = GKA_PARSE_DONE;
  }
}
/* ----- close cell ----- */
void close_incr(struct cell_match_pattern *pattern, char c){
    if(c == '('){
      if(ctx->stack){
          ctx->current = ctx->stack->cell;
          ctx->stack = ctx->stack->previous;
      }else{
          ctx->current = NULL;
      }
      pattern->state = GKA_PARSE_DONE;
    }
}
/* ----- quote ' ----- */
void close_incr(struct cell_match_pattern *pattern, char c){
    if(c == '\''){
       pattern->accent = GKA_IN_QUOTE;
    }
}
/* ----- not ! ----- */
void close_incr(struct cell_match_pattern *pattern, char c){
    if(c == '\''){
       pattern->accent = GKA_PARSE_DONE;
       pattern->state = GKA_PARSE_DONE;
    }
}
/* ----- super ^ ----- */
/* ----- key ----- */
/* ----- number ----- */
/* ----- symbol ----- */

/*
void parse_char(struct parse_ctx *ctx, char c){

    struct cell *slot;
    struct cell *new;
    struct cell *stack_cell;
    struct cell *enclosing;
    struct symbol *symbol;
    
    if(ctx->state == IN_COMMENT){
        if(c == '\n'){
            finalize_cell(ctx);
            ctx->state = START;

            return;
        }else{
            string_append_char(get_or_create_token(ctx), c);
        }

        return;
    }

    if(ctx->state == IN_STRING){
        if(c == '\\'){
            /* if we are escaping the \ then take no action */
            if(ctx->in_escape){
                ctx->in_escape = 0;
            }else{
                ctx->in_escape = 1;
                return;
            }
        }
        if(ctx->in_escape){
            ctx->in_escape = 0;
            if(c == 'n'){
                c = '\n';
            }
            if(c == 't'){
                c = '\t';
            }
        }

        if(!ctx->in_escape && c == ctx->closing_char){
            finalize_cell(ctx);
            ctx->state = START;

            return;
        }else{
            string_append_char(get_or_create_token(ctx), c);
        }

        return;
    }

    if(ctx->state == IN_KEY){
        if(c != ' ' && c != ')'){
            string_append_char(get_or_create_token(ctx), c);
            return;
        }
    }

    if(c == '('){
        finalize_cell(ctx);

        new = new_cell();
        if(ctx->state == IN_QUOTE){
            ctx->current->value = new_cell_value_obj(new);
            ctx->stack = push_parse_stack(ctx->stack, ctx->current, NULL);
            ctx->current = new;
        }else{
            stack_cell = new_cell();
            stack_cell->branch = new;

            slot = ctx->current;

            ctx->current = new;
            ctx->stack = push_parse_stack(ctx->stack, stack_cell, NULL);

            if(!ctx->root){
                ctx->root = stack_cell;
            }else{
                if(slot){
                    slot->next = stack_cell;
                }
            }
        }

        ctx->state = IN_CELL;
        return;
    }

    if(c == ')'){

        finalize_cell(ctx);
        if(ctx->stack){
            ctx->current = ctx->stack->cell;
            ctx->stack = ctx->stack->previous;
        }else{
            ctx->current = NULL;
        }
        return;
    }

    if(is_whitespace(c)){
        if(ctx->token && ctx->token->length){
            finalize_cell(ctx);
        }
        return;
    }

    if(ctx->state == START){
        new = new_cell();
        if(new == NULL){
            char msg[] = "Error allocating root cell aborting";
            exit(1);
        }

        slot = ctx->current;
        ctx->current = new;
        if(!ctx->root){
            ctx->root = new;
        }else{
            if(slot){
                slot->next = new;
            }
        }
        ctx->state = IN_CELL;
    }

    if(c == '"'){
       ctx->state = IN_STRING; 
       ctx->closing_char = '"';
       return;
    }

    if(c == '.'){
       ctx->state = IN_KEY; 
       ctx->closing_char = ' ';
       return;
    }

    if(c == '\''){
       ctx->state = IN_QUOTE; 
       ctx->closing_char = ' ';
       return;
    }

    if(c == '/'){
       if(ctx->has_comment_char){
          ctx->state = IN_COMMENT;
       }
       ctx->has_comment_char = 1; 
       return;
    }

    string_append_char(get_or_create_token(ctx), c);
}
*/
